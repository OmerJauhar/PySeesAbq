"""
Converter module for transforming Abaqus data to OpenSeesPy Python script.

This module provides the core conversion functionality from Abaqus finite element
models to OpenSeesPy format, handling nodes, elements, materials, sections,
boundary conditions, and loads.
"""

import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

from .parser import AbaqusParser
from .mapping import ELEMENT_TYPE_MAPPING, get_opensees_element_type


logger = logging.getLogger(__name__)


class AbaqusToOpenSeesConverter:
    """
    Converter class for transforming Abaqus finite element models to OpenSeesPy.
    
    This class handles the conversion of all major components including nodes,
    elements, materials, sections, boundary conditions, and loads.
    """
    
    def __init__(self, parser_data: Optional[AbaqusParser] = None):
        """
        Initialize converter with parsed Abaqus data.
        
        Args:
            parser_data: Parsed Abaqus data. If None, must be provided during convert().
        """
        self.parser_data = parser_data
        self.opensees_script: List[str] = []
        self.material_tags: Dict[str, int] = {}  # Maps Abaqus material names to OpenSees tags
        self.section_tags: Dict[str, int] = {}   # Maps Abaqus section names to OpenSees tags
        self.element_tags: Dict[str, int] = {}   # Maps Abaqus element IDs to OpenSees tags
        
    def convert(self, inp_file_path: Optional[str] = None) -> str:
        """
        Convert Abaqus .inp file to OpenSeesPy script.
        
        Args:
            inp_file_path: Path to Abaqus .inp file if parser_data not provided.
            
        Returns:
            Complete OpenSeesPy Python script as string.
            
        Raises:
            ValueError: If no Abaqus data is provided.
            FileNotFoundError: If inp_file_path doesn't exist.
        """
        if inp_file_path and not self.parser_data:
            parser = AbaqusParser()
            self.parser_data = parser.parse(inp_file_path)
        
        if not self.parser_data:
            raise ValueError("No Abaqus data provided for conversion.")
        
        logger.info("Starting Abaqus to OpenSeesPy conversion")
        
        # Initialize script
        self._add_script_header()
        
        # Process model components in logical order
        self._process_nodes()
        self._process_materials()
        self._process_sections()
        self._process_elements()
        self._process_boundaries()
        self._process_loads()
        
        # Add analysis commands
        self._add_analysis_setup()
        
        # Add footer
        self._add_script_footer()
        
        logger.info("Conversion completed successfully")
        return "\n".join(self.opensees_script)
    
    def _add_script_header(self) -> None:
        """Add script header with metadata and model initialization."""
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        header = [
            "#!/usr/bin/env python3",
            '"""',
            "OpenSeesPy Model - Converted from Abaqus .inp file",
            f"Generated by PySeesAbq (RAPID-CLIO) on {current_time}",
            "Maintained by: Omer Jauhar",
            "",
            "This script contains the converted finite element model.",
            "Make sure OpenSeesPy is installed: pip install openseespy",
            '"""',
            "",
            "import sys",
            "try:",
            "    from openseespy.opensees import *",
            "except ImportError:",
            '    print("Error: OpenSeesPy not found. Install with: pip install openseespy")',
            "    sys.exit(1)",
            "",
            "# Model Statistics",
            f"# Nodes: {len(self.parser_data.nodes)}",
            f"# Elements: {len(self.parser_data.elements)}",
            f"# Materials: {len(self.parser_data.materials)}",
            f"# Sections: {len(self.parser_data.sections)}",
            "",
            "# Initialize OpenSees Model",
            "wipe()",
            "model('basic', '-ndm', 3, '-ndf', 6)",
            ""
        ]
        
        self.opensees_script.extend(header)
    
    def _process_nodes(self) -> None:
        """Process nodes from Abaqus data."""
        if not self.parser_data.nodes:
            logger.warning("No nodes found in Abaqus data")
            return
            
        self.opensees_script.append("# ============================================")
        self.opensees_script.append("# NODES")
        self.opensees_script.append("# ============================================")
        
        for node_id, coords in self.parser_data.nodes.items():
            x, y, z = coords
            self.opensees_script.append(f"node({node_id}, {x:.6f}, {y:.6f}, {z:.6f})")
            
        self.opensees_script.append(f"# Total nodes: {len(self.parser_data.nodes)}")
        self.opensees_script.append("")
    
    def _process_materials(self) -> None:
        """Process materials from Abaqus data."""
        if not self.parser_data.materials:
            logger.warning("No materials found in Abaqus data")
            return
            
        self.opensees_script.append("# ============================================")
        self.opensees_script.append("# MATERIALS")
        self.opensees_script.append("# ============================================")
        
        material_tag = 1
        for material_name, properties in self.parser_data.materials.items():
            E = properties.get('E', 2.1e11)  # Default steel elastic modulus (Pa)
            nu = properties.get('nu', 0.3)   # Default Poisson's ratio
            rho = properties.get('rho', 7850.0)  # Default steel density (kg/mÂ³)
            
            self.opensees_script.append(f"# Material: {material_name}")
            self.opensees_script.append(
                f"nDMaterial('ElasticIsotropic', {material_tag}, {E:.3e}, {nu:.3f}, {rho:.1f})"
            )
            self.material_tags[material_name] = material_tag
            material_tag += 1
        
        self.opensees_script.append(f"# Total materials: {len(self.parser_data.materials)}")
        self.opensees_script.append("")
    
    def _process_sections(self):
        """Process sections from Abaqus data."""
        self.opensees_script.append("# Sections")
        
        section_tag = 1
        for section_name, properties in self.parser_data.sections.items():
            material_name = properties.get('material')
            thickness = properties.get('thickness', 1.0)  # Default thickness
            
            if material_name in self.material_tags:
                material_tag = self.material_tags[material_name]
                material_props = self.parser_data.materials.get(material_name, {})
                E = material_props.get('E', 1.0)  # Default elastic modulus
                nu = material_props.get('nu', 0.3)  # Default Poisson's ratio
                
                self.opensees_script.append(
                    f"section('ElasticMembranePlateSection', {section_tag}, {E}, {nu}, {thickness}, {material_tag})"
                )
                self.section_tags[section_name] = section_tag
                section_tag += 1
        
        self.opensees_script.append("")
    
    def _process_elements(self) -> None:
        """Process elements from Abaqus data with improved mapping."""
        if not self.parser_data.elements:
            logger.warning("No elements found in Abaqus data")
            return
            
        self.opensees_script.append("# ============================================")
        self.opensees_script.append("# ELEMENTS")
        self.opensees_script.append("# ============================================")
        
        # Group elements by type for batch processing
        elements_by_type: Dict[str, List[tuple]] = {}
        for element_id, element_data in self.parser_data.elements.items():
            element_type = element_data['type']
            if element_type not in elements_by_type:
                elements_by_type[element_type] = []
            elements_by_type[element_type].append((element_id, element_data['nodes']))
        
        # Process each element type
        for element_type, elements in elements_by_type.items():
            self.opensees_script.append(f"# {element_type} Elements ({len(elements)} elements)")
            
            # Determine the OpenSeesPy element type
            opensees_element_type = get_opensees_element_type(element_type)
            
            # Find appropriate section/material tag for these elements
            section_tag = self._get_section_tag_for_element_type(element_type)
            
            # Create elements in OpenSeesPy
            for element_id, node_ids in elements:
                nodes_str = ", ".join(map(str, node_ids))
                
                if opensees_element_type in ['ShellMITC4', 'ShellDKGT']:
                    self.opensees_script.append(
                        f"element('{opensees_element_type}', {element_id}, {nodes_str}, {section_tag})"
                    )
                elif opensees_element_type in ['stdBrick', 'FourNodeTetrahedron']:
                    # For solid elements, use material tag directly
                    material_tag = list(self.material_tags.values())[0] if self.material_tags else 1
                    self.opensees_script.append(
                        f"element('{opensees_element_type}', {element_id}, {nodes_str}, {material_tag})"
                    )
                else:
                    # Default element creation
                    self.opensees_script.append(
                        f"element('{opensees_element_type}', {element_id}, {nodes_str}, {section_tag})"
                    )
            
            self.opensees_script.append("")
        
        self.opensees_script.append(f"# Total elements: {len(self.parser_data.elements)}")
        self.opensees_script.append("")
    
    def _get_section_tag_for_element_type(self, element_type: str) -> int:
        """
        Get appropriate section tag for a given element type.
        
        Args:
            element_type: Abaqus element type
            
        Returns:
            Section tag to use for this element type
        """
        # For simplicity, use the first available section tag
        if self.section_tags:
            return list(self.section_tags.values())[0]
        return 1
    
    def _map_element_type(self, abaqus_element_type: str) -> str:
        """
        Map Abaqus element types to OpenSeesPy element types.
        
        Args:
            abaqus_element_type: Abaqus element type.
            
        Returns:
            Equivalent OpenSeesPy element type.
        """
        return get_opensees_element_type(abaqus_element_type)
    
    def _process_boundaries(self) -> None:
        """Process boundary conditions from Abaqus data."""
        if not self.parser_data.boundaries:
            logger.warning("No boundary conditions found in Abaqus data")
            return
            
        self.opensees_script.append("# ============================================")
        self.opensees_script.append("# BOUNDARY CONDITIONS")
        self.opensees_script.append("# ============================================")
        
        for node_id, constraints in self.parser_data.boundaries.items():
            constraints_str = ", ".join(map(str, constraints))
            self.opensees_script.append(f"fix({node_id}, {constraints_str})")
        
        self.opensees_script.append(f"# Total constrained nodes: {len(self.parser_data.boundaries)}")
        self.opensees_script.append("")
    
    def _process_loads(self) -> None:
        """Process loads from Abaqus data."""
        if not self.parser_data.loads:
            logger.info("No loads found in Abaqus data")
            return
            
        self.opensees_script.append("# ============================================")
        self.opensees_script.append("# LOADS")
        self.opensees_script.append("# ============================================")
        self.opensees_script.append("pattern('Plain', 1, 1)")
        
        for node_id, loads in self.parser_data.loads.items():
            load_str = ", ".join(f"{load:.6f}" for load in loads)
            self.opensees_script.append(f"load({node_id}, {load_str})")
        
        self.opensees_script.append(f"# Total loaded nodes: {len(self.parser_data.loads)}")
        self.opensees_script.append("")
    
    def _add_analysis_setup(self) -> None:
        """Add analysis setup commands."""
        self.opensees_script.extend([
            "# ============================================",
            "# ANALYSIS SETUP",
            "# ============================================",
            "",
            "# Analysis parameters",
            "constraints('Plain')",
            "numberer('Plain')",
            "system('BandGeneral')",
            "test('NormDispIncr', 1.0e-6, 10)",
            "algorithm('Newton')",
            "integrator('LoadControl', 1.0)",
            "analysis('Static')",
            "",
            "# Run analysis",
            "print('Starting analysis...')",
            "ok = analyze(1)",
            "if ok != 0:",
            "    print('Analysis failed!')",
            "else:",
            "    print('Analysis completed successfully!')",
            ""
        ])

    def _add_script_footer(self) -> None:
        """Add script footer with post-processing commands."""
        self.opensees_script.extend([
            "# ============================================",
            "# POST-PROCESSING",
            "# ============================================",
            "",
            "# Print model information",
            "print('\\nModel Summary:')",
            f"print('Nodes: {len(self.parser_data.nodes) if self.parser_data else 0}')",
            f"print('Elements: {len(self.parser_data.elements) if self.parser_data else 0}')",
            f"print('Materials: {len(self.parser_data.materials) if self.parser_data else 0}')",
            "",
            "# Uncomment the following lines for detailed output:",
            "# printModel()",
            "# printA()",
            "",
            "print('\\nOpenSeesPy model ready for further analysis!')",
            "print('Generated by PySeesAbq (RAPID-CLIO) - Maintained by Omer Jauhar')"
        ])

# Legacy function for backward compatibility
def convert(inp_file_path: str, output_file_path: Optional[str] = None, return_string: bool = False) -> Optional[str]:
    """
    Convert Abaqus .inp file to OpenSeesPy Python script.
    
    This is a convenience function that creates a parser and converter internally.
    For more control, use AbaqusParser and AbaqusToOpenSeesConverter directly.
    
    Args:
        inp_file_path: Path to Abaqus .inp file.
        output_file_path: Path to save the OpenSeesPy script. If None, doesn't save to file.
        return_string: Whether to return the script as a string. Default is False.
                                       
    Returns:
        OpenSeesPy script if return_string is True, else None.
        
    Raises:
        FileNotFoundError: If inp_file_path doesn't exist.
    """
    logger.info(f"Converting {inp_file_path} using legacy convert function")
    
    parser = AbaqusParser()
    parser_data = parser.parse(inp_file_path)
    
    converter = AbaqusToOpenSeesConverter(parser_data)
    opensees_script = converter.convert()
    
    if output_file_path:
        with open(output_file_path, 'w', encoding='utf-8') as f:
            f.write(opensees_script)
        logger.info(f"Saved converted script to {output_file_path}")
    
    if return_string:
        return opensees_script
    
    return None